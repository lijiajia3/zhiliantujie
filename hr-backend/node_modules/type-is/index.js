

'use strict'



var contentType = require('content-type')
var mime = require('mime-types')
var typer = require('media-typer')



module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch



function typeis (value, types_) {
  var i
  var types = types_

  
  var val = tryNormalizeType(value)

  
  if (!val) {
    return false
  }

  
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  
  return false
}



function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}



function typeofrequest (req, types_) {
  
  if (!hasbody(req)) return null
  
  var types = arguments.length > 2
    ? Array.prototype.slice.call(arguments, 1)
    : types_
  
  var value = req.headers['content-type']

  return typeis(value, types)
}



function normalize (type) {
  if (typeof type !== 'string') {
    
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart*+json" expando
    return '*

function mimeMatch (expected, actual) {
  
  if (expected === false) {
    return false
  }

  
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  
  if (expectedParts[1].slice(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length)
  }

  
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}


function normalizeType (value) {
  
  var type = contentType.parse(value).type

  return typer.test(type) ? type : null
}


function tryNormalizeType (value) {
  try {
    return value ? normalizeType(value) : null
  } catch (err) {
    return null
  }
}
