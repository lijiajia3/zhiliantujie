

from __future__ import annotations

import contextlib
import typing

if typing.TYPE_CHECKING:
    from ._models import Request, Response  

__all__ = [
    "CloseError",
    "ConnectError",
    "ConnectTimeout",
    "CookieConflict",
    "DecodingError",
    "HTTPError",
    "HTTPStatusError",
    "InvalidURL",
    "LocalProtocolError",
    "NetworkError",
    "PoolTimeout",
    "ProtocolError",
    "ProxyError",
    "ReadError",
    "ReadTimeout",
    "RemoteProtocolError",
    "RequestError",
    "RequestNotRead",
    "ResponseNotRead",
    "StreamClosed",
    "StreamConsumed",
    "StreamError",
    "TimeoutException",
    "TooManyRedirects",
    "TransportError",
    "UnsupportedProtocol",
    "WriteError",
    "WriteTimeout",
]


class HTTPError(Exception):
    

    def __init__(self, message: str) -> None:
        super().__init__(message)
        self._request: Request | None = None

    @property
    def request(self) -> Request:
        if self._request is None:
            raise RuntimeError("The .request property has not been set.")
        return self._request

    @request.setter
    def request(self, request: Request) -> None:
        self._request = request


class RequestError(HTTPError):
    

    def __init__(self, message: str, *, request: Request | None = None) -> None:
        super().__init__(message)
        
        
        
        
        
        
        self._request = request


class TransportError(RequestError):
    





class TimeoutException(TransportError):
    


class ConnectTimeout(TimeoutException):
    


class ReadTimeout(TimeoutException):
    


class WriteTimeout(TimeoutException):
    


class PoolTimeout(TimeoutException):
    





class NetworkError(TransportError):
    


class ReadError(NetworkError):
    


class WriteError(NetworkError):
    


class ConnectError(NetworkError):
    


class CloseError(NetworkError):
    





class ProxyError(TransportError):
    


class UnsupportedProtocol(TransportError):
    


class ProtocolError(TransportError):
    


class LocalProtocolError(ProtocolError):
    


class RemoteProtocolError(ProtocolError):
    





class DecodingError(RequestError):
    


class TooManyRedirects(RequestError):
    





class HTTPStatusError(HTTPError):
    

    def __init__(self, message: str, *, request: Request, response: Response) -> None:
        super().__init__(message)
        self.request = request
        self.response = response


class InvalidURL(Exception):
    

    def __init__(self, message: str) -> None:
        super().__init__(message)


class CookieConflict(Exception):
    

    def __init__(self, message: str) -> None:
        super().__init__(message)








class StreamError(RuntimeError):
    

    def __init__(self, message: str) -> None:
        super().__init__(message)


class StreamConsumed(StreamError):
    

    def __init__(self) -> None:
        message = (
            "Attempted to read or stream some content, but the content has "
            "already been streamed. For requests, this could be due to passing "
            "a generator as request content, and then receiving a redirect "
            "response or a secondary request as part of an authentication flow."
            "For responses, this could be due to attempting to stream the response "
            "content more than once."
        )
        super().__init__(message)


class StreamClosed(StreamError):
    

    def __init__(self) -> None:
        message = (
            "Attempted to read or stream content, but the stream has " "been closed."
        )
        super().__init__(message)


class ResponseNotRead(StreamError):
    

    def __init__(self) -> None:
        message = (
            "Attempted to access streaming response content,"
            " without having called `read()`."
        )
        super().__init__(message)


class RequestNotRead(StreamError):
    

    def __init__(self) -> None:
        message = (
            "Attempted to access streaming request content,"
            " without having called `read()`."
        )
        super().__init__(message)


@contextlib.contextmanager
def request_context(
    request: Request | None = None,
) -> typing.Iterator[None]:
    
    try:
        yield
    except RequestError as exc:
        if request is not None:
            exc.request = request
        raise exc
