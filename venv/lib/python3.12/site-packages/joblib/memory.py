






import asyncio
import datetime
import functools
import inspect
import logging
import os
import pathlib
import pydoc
import re
import textwrap
import time
import tokenize
import traceback
import warnings
import weakref

from . import hashing
from ._store_backends import CacheWarning  
from ._store_backends import FileSystemStoreBackend, StoreBackendBase
from .func_inspect import (filter_args, format_call, format_signature,
                           get_func_code, get_func_name)
from .logger import Logger, format_time, pformat

FIRST_LINE_TEXT = "














def extract_first_line(func_code):
    
    if func_code.startswith(FIRST_LINE_TEXT):
        func_code = func_code.split('\n')
        first_line = int(func_code[0][len(FIRST_LINE_TEXT):])
        func_code = '\n'.join(func_code[1:])
    else:
        first_line = -1
    return func_code, first_line


class JobLibCollisionWarning(UserWarning):
    


_STORE_BACKENDS = {'local': FileSystemStoreBackend}


def register_store_backend(backend_name, backend):
    
    if not isinstance(backend_name, str):
        raise ValueError("Store backend name should be a string, "
                         "'{0}' given.".format(backend_name))
    if backend is None or not issubclass(backend, StoreBackendBase):
        raise ValueError("Store backend should inherit "
                         "StoreBackendBase, "
                         "'{0}' given.".format(backend))

    _STORE_BACKENDS[backend_name] = backend


def _store_backend_factory(backend, location, verbose=0, backend_options=None):
    
    if backend_options is None:
        backend_options = {}

    if isinstance(location, pathlib.Path):
        location = str(location)

    if isinstance(location, StoreBackendBase):
        return location
    elif isinstance(location, str):
        obj = None
        location = os.path.expanduser(location)
        
        
        
        for backend_key, backend_obj in _STORE_BACKENDS.items():
            if backend == backend_key:
                obj = backend_obj()

        
        
        if obj is None:
            raise TypeError('Unknown location {0} or backend {1}'.format(
                            location, backend))

        
        
        obj.configure(location, verbose=verbose,
                      backend_options=backend_options)
        return obj
    elif location is not None:
        warnings.warn(
            "Instantiating a backend using a {} as a location is not "
            "supported by joblib. Returning None instead.".format(
                location.__class__.__name__), UserWarning)

    return None


def _build_func_identifier(func):
    
    modules, funcname = get_func_name(func)
    
    return os.path.join(*modules, funcname)




_FUNCTION_HASHES = weakref.WeakKeyDictionary()





class MemorizedResult(Logger):
    
    def __init__(self, location, call_id, backend='local', mmap_mode=None,
                 verbose=0, timestamp=None, metadata=None):
        Logger.__init__(self)
        self._call_id = call_id
        self.store_backend = _store_backend_factory(backend, location,
                                                    verbose=verbose)
        self.mmap_mode = mmap_mode

        if metadata is not None:
            self.metadata = metadata
        else:
            self.metadata = self.store_backend.get_metadata(self._call_id)

        self.duration = self.metadata.get('duration', None)
        self.verbose = verbose
        self.timestamp = timestamp

    @property
    def func(self):
        return self.func_id

    @property
    def func_id(self):
        return self._call_id[0]

    @property
    def args_id(self):
        return self._call_id[1]

    @property
    def argument_hash(self):
        warnings.warn(
            "The 'argument_hash' attribute has been deprecated in version "
            "0.12 and will be removed in version 0.14.\n"
            "Use `args_id` attribute instead.",
            DeprecationWarning, stacklevel=2)
        return self.args_id

    def get(self):
        
        try:
            return self.store_backend.load_item(
                self._call_id,
                timestamp=self.timestamp,
                metadata=self.metadata,
                verbose=self.verbose
            )
        except ValueError as exc:
            new_exc = KeyError(
                "Error while trying to load a MemorizedResult's value. "
                "It seems that this folder is corrupted : {}".format(
                    os.path.join(self.store_backend.location, *self._call_id)))
            raise new_exc from exc

    def clear(self):
        
        self.store_backend.clear_item(self._call_id)

    def __repr__(self):
        return '{}(location="{}", func="{}", args_id="{}")'.format(
            self.__class__.__name__, self.store_backend.location,
            *self._call_id
        )

    def __getstate__(self):
        state = self.__dict__.copy()
        state['timestamp'] = None
        return state


class NotMemorizedResult(object):
    
    __slots__ = ('value', 'valid')

    def __init__(self, value):
        self.value = value
        self.valid = True

    def get(self):
        if self.valid:
            return self.value
        else:
            raise KeyError("No value stored.")

    def clear(self):
        self.valid = False
        self.value = None

    def __repr__(self):
        if self.valid:
            return ('{class_name}({value})'
                    .format(class_name=self.__class__.__name__,
                            value=pformat(self.value)))
        else:
            return self.__class__.__name__ + ' with no value'

    
    def __getstate__(self):
        return {"valid": self.valid, "value": self.value}

    def __setstate__(self, state):
        self.valid = state["valid"]
        self.value = state["value"]





class NotMemorizedFunc(object):
    
    
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

    def call_and_shelve(self, *args, **kwargs):
        return NotMemorizedResult(self.func(*args, **kwargs))

    def __repr__(self):
        return '{0}(func={1})'.format(self.__class__.__name__, self.func)

    def clear(self, warn=True):
        
        pass

    def call(self, *args, **kwargs):
        return self.func(*args, **kwargs), {}

    def check_call_in_cache(self, *args, **kwargs):
        return False





class AsyncNotMemorizedFunc(NotMemorizedFunc):
    async def call_and_shelve(self, *args, **kwargs):
        return NotMemorizedResult(await self.func(*args, **kwargs))





class MemorizedFunc(Logger):
    
    
    
    

    def __init__(self, func, location, backend='local', ignore=None,
                 mmap_mode=None, compress=False, verbose=1, timestamp=None,
                 cache_validation_callback=None):
        Logger.__init__(self)
        self.mmap_mode = mmap_mode
        self.compress = compress
        self.func = func
        self.cache_validation_callback = cache_validation_callback
        self.func_id = _build_func_identifier(func)
        self.ignore = ignore if ignore is not None else []
        self._verbose = verbose

        
        self.store_backend = _store_backend_factory(backend, location,
                                                    verbose=verbose,
                                                    backend_options=dict(
                                                        compress=compress,
                                                        mmap_mode=mmap_mode),
                                                    )
        if self.store_backend is not None:
            
            self.store_backend.store_cached_func_code([self.func_id])

        self.timestamp = timestamp if timestamp is not None else time.time()
        try:
            functools.update_wrapper(self, func)
        except Exception:
            pass  
        if inspect.isfunction(func):
            doc = pydoc.TextDoc().document(func)
            
            doc = doc.replace('\n', '\n\n', 1)
            
            doc = re.sub('\x08.', '', doc)
        else:
            
            doc = func.__doc__
        self.__doc__ = 'Memoized version of %s' % doc

        self._func_code_info = None
        self._func_code_id = None

    def _is_in_cache_and_valid(self, call_id):
        
        
        if not self._check_previous_func_code(stacklevel=4):
            return False

        
        if not self.store_backend.contains_item(call_id):
            return False

        
        metadata = self.store_backend.get_metadata(call_id)
        if (self.cache_validation_callback is not None and
                not self.cache_validation_callback(metadata)):
            self.store_backend.clear_item(call_id)
            return False

        return True

    def _cached_call(self, args, kwargs, shelving):
        
        args_id = self._get_args_id(*args, **kwargs)
        call_id = (self.func_id, args_id)
        _, func_name = get_func_name(self.func)
        func_info = self.store_backend.get_cached_func_info([self.func_id])
        location = func_info['location']

        if self._verbose >= 20:
            logging.basicConfig(level=logging.INFO)
            _, signature = format_signature(self.func, *args, **kwargs)
            self.info(
                textwrap.dedent(
                    f
                )
            )

        
        
        
        if self._is_in_cache_and_valid(call_id):
            if shelving:
                return self._get_memorized_result(call_id), {}

            try:
                start_time = time.time()
                output = self._load_item(call_id)
                if self._verbose > 4:
                    self._print_duration(time.time() - start_time,
                                         context='cache loaded ')
                return output, {}
            except Exception:
                
                _, signature = format_signature(self.func, *args, **kwargs)
                self.warn('Exception while loading results for '
                          '{}\n {}'.format(signature, traceback.format_exc()))

        if self._verbose > 10:
            self.warn(
                f"Computing func {func_name}, argument hash {args_id} "
                f"in location {location}"
            )

        
        return self._call(call_id, args, kwargs, shelving)

    @property
    def func_code_info(self):
        
        
        if hasattr(self.func, '__code__'):
            if self._func_code_id is None:
                self._func_code_id = id(self.func.__code__)
            elif id(self.func.__code__) != self._func_code_id:
                
                self._func_code_info = None

        if self._func_code_info is None:
            
            
            
            
            
            
            
            
            self._func_code_info = get_func_code(self.func)
        return self._func_code_info

    def call_and_shelve(self, *args, **kwargs):
        
        
        return self._cached_call(args, kwargs, shelving=True)[0]

    def __call__(self, *args, **kwargs):
        
        return self._cached_call(args, kwargs, shelving=False)[0]

    def __getstate__(self):
        
        
        
        _ = self.func_code_info

        
        
        state = self.__dict__.copy()
        state['timestamp'] = None

        
        state['_func_code_id'] = None

        return state

    def check_call_in_cache(self, *args, **kwargs):
        
        call_id = (self.func_id, self._get_args_id(*args, **kwargs))
        return self.store_backend.contains_item(call_id)

    
    
    

    def _get_args_id(self, *args, **kwargs):
        
        return hashing.hash(filter_args(self.func, self.ignore, args, kwargs),
                            coerce_mmap=self.mmap_mode is not None)

    def _hash_func(self):
        
        func_code_h = hash(getattr(self.func, '__code__', None))
        return id(self.func), hash(self.func), func_code_h

    def _write_func_code(self, func_code, first_line):
        
        
        
        
        
        
        func_code = u'%s %i\n%s' % (FIRST_LINE_TEXT, first_line, func_code)
        self.store_backend.store_cached_func_code([self.func_id], func_code)

        
        is_named_callable = (hasattr(self.func, '__name__') and
                             self.func.__name__ != '<lambda>')
        if is_named_callable:
            
            
            func_hash = self._hash_func()
            try:
                _FUNCTION_HASHES[self.func] = func_hash
            except TypeError:
                
                pass

    def _check_previous_func_code(self, stacklevel=2):
        
        
        
        
        
        try:
            if self.func in _FUNCTION_HASHES:
                
                
                
                func_hash = self._hash_func()
                if func_hash == _FUNCTION_HASHES[self.func]:
                    return True
        except TypeError:
            
            pass

        
        
        
        func_code, source_file, first_line = self.func_code_info
        try:
            old_func_code, old_first_line = extract_first_line(
                self.store_backend.get_cached_func_code([self.func_id]))
        except (IOError, OSError):  
            self._write_func_code(func_code, first_line)
            return False
        if old_func_code == func_code:
            return True

        
        
        

        _, func_name = get_func_name(self.func, resolv_alias=False,
                                     win_characters=False)
        if old_first_line == first_line == -1 or func_name == '<lambda>':
            if not first_line == -1:
                func_description = ("{0} ({1}:{2})"
                                    .format(func_name, source_file,
                                            first_line))
            else:
                func_description = func_name
            warnings.warn(JobLibCollisionWarning(
                "Cannot detect name collisions for function '{0}'"
                .format(func_description)), stacklevel=stacklevel)

        
        
        
        
        if not old_first_line == first_line and source_file is not None:
            if os.path.exists(source_file):
                _, func_name = get_func_name(self.func, resolv_alias=False)
                num_lines = len(func_code.split('\n'))
                with tokenize.open(source_file) as f:
                    on_disk_func_code = f.readlines()[
                        old_first_line - 1:old_first_line - 1 + num_lines - 1]
                on_disk_func_code = ''.join(on_disk_func_code)
                possible_collision = (on_disk_func_code.rstrip() ==
                                      old_func_code.rstrip())
            else:
                possible_collision = source_file.startswith('<doctest ')
            if possible_collision:
                warnings.warn(JobLibCollisionWarning(
                    'Possible name collisions between functions '
                    "'%s' (%s:%i) and '%s' (%s:%i)" %
                    (func_name, source_file, old_first_line,
                     func_name, source_file, first_line)),
                    stacklevel=stacklevel)

        
        
        if self._verbose > 10:
            _, func_name = get_func_name(self.func, resolv_alias=False)
            self.warn("Function {0} (identified by {1}) has changed"
                      ".".format(func_name, self.func_id))
        self.clear(warn=True)
        return False

    def clear(self, warn=True):
        
        func_id = self.func_id
        if self._verbose > 0 and warn:
            self.warn("Clearing function cache identified by %s" % func_id)
        self.store_backend.clear_path([func_id, ])

        func_code, _, first_line = self.func_code_info
        self._write_func_code(func_code, first_line)

    def call(self, *args, **kwargs):
        
        call_id = (self.func_id, self._get_args_id(*args, **kwargs))

        
        return self._call(call_id, args, kwargs)

    def _call(self, call_id, args, kwargs, shelving=False):
        
        self._before_call(args, kwargs)
        start_time = time.time()
        output = self.func(*args, **kwargs)
        return self._after_call(call_id, args, kwargs, shelving,
                                output, start_time)

    def _before_call(self, args, kwargs):
        if self._verbose > 0:
            print(format_call(self.func, args, kwargs))

    def _after_call(self, call_id, args, kwargs, shelving, output, start_time):
        self.store_backend.dump_item(call_id, output, verbose=self._verbose)
        duration = time.time() - start_time
        if self._verbose > 0:
            self._print_duration(duration)
        metadata = self._persist_input(duration, call_id, args, kwargs)
        if shelving:
            return self._get_memorized_result(call_id, metadata), metadata

        if self.mmap_mode is not None:
            
            
            output = self._load_item(call_id, metadata)
        return output, metadata

    def _persist_input(self, duration, call_id, args, kwargs,
                       this_duration_limit=0.5):
        
        start_time = time.time()
        argument_dict = filter_args(self.func, self.ignore,
                                    args, kwargs)

        input_repr = dict((k, repr(v)) for k, v in argument_dict.items())
        
        
        metadata = {
            "duration": duration, "input_args": input_repr, "time": start_time,
        }

        self.store_backend.store_metadata(call_id, metadata)

        this_duration = time.time() - start_time
        if this_duration > this_duration_limit:
            
            
            
            
            
            
            warnings.warn("Persisting input arguments took %.2fs to run."
                          "If this happens often in your code, it can cause "
                          "performance problems "
                          "(results will be correct in all cases). "
                          "The reason for this is probably some large input "
                          "arguments for a wrapped function."
                          % this_duration, stacklevel=5)
        return metadata

    def _get_memorized_result(self, call_id, metadata=None):
        return MemorizedResult(self.store_backend, call_id,
                               metadata=metadata, timestamp=self.timestamp,
                               verbose=self._verbose - 1)

    def _load_item(self, call_id, metadata=None):
        return self.store_backend.load_item(call_id, metadata=metadata,
                                            timestamp=self.timestamp,
                                            verbose=self._verbose)

    def _print_duration(self, duration, context=''):
        _, name = get_func_name(self.func)
        msg = f"{name} {context}- {format_time(duration)}"
        print(max(0, (80 - len(msg))) * '_' + msg)

    
    
    

    def __repr__(self):
        return '{class_name}(func={func}, location={location})'.format(
            class_name=self.__class__.__name__,
            func=self.func,
            location=self.store_backend.location,)





class AsyncMemorizedFunc(MemorizedFunc):
    async def __call__(self, *args, **kwargs):
        out = self._cached_call(args, kwargs, shelving=False)
        out = await out if asyncio.iscoroutine(out) else out
        return out[0]  

    async def call_and_shelve(self, *args, **kwargs):
        out = self._cached_call(args, kwargs, shelving=True)
        out = await out if asyncio.iscoroutine(out) else out
        return out[0]  

    async def call(self, *args, **kwargs):
        out = super().call(*args, **kwargs)
        return await out if asyncio.iscoroutine(out) else out

    async def _call(self, call_id, args, kwargs, shelving=False):
        self._before_call(args, kwargs)
        start_time = time.time()
        output = await self.func(*args, **kwargs)
        return self._after_call(
            call_id, args, kwargs, shelving, output, start_time
        )





class Memory(Logger):
    
    
    
    

    def __init__(self, location=None, backend='local',
                 mmap_mode=None, compress=False, verbose=1, bytes_limit=None,
                 backend_options=None):
        Logger.__init__(self)
        self._verbose = verbose
        self.mmap_mode = mmap_mode
        self.timestamp = time.time()
        if bytes_limit is not None:
            warnings.warn(
                "bytes_limit argument has been deprecated. It will be removed "
                "in version 1.5. Please pass its value directly to "
                "Memory.reduce_size.",
                category=DeprecationWarning
            )
        self.bytes_limit = bytes_limit
        self.backend = backend
        self.compress = compress
        if backend_options is None:
            backend_options = {}
        self.backend_options = backend_options

        if compress and mmap_mode is not None:
            warnings.warn('Compressed results cannot be memmapped',
                          stacklevel=2)

        self.location = location
        if isinstance(location, str):
            location = os.path.join(location, 'joblib')

        self.store_backend = _store_backend_factory(
            backend, location, verbose=self._verbose,
            backend_options=dict(compress=compress, mmap_mode=mmap_mode,
                                 **backend_options))

    def cache(self, func=None, ignore=None, verbose=None, mmap_mode=False,
              cache_validation_callback=None):
        
        if (cache_validation_callback is not None and
                not callable(cache_validation_callback)):
            raise ValueError(
                "cache_validation_callback needs to be callable. "
                f"Got {cache_validation_callback}."
            )
        if func is None:
            
            
            return functools.partial(
                self.cache, ignore=ignore,
                mmap_mode=mmap_mode,
                verbose=verbose,
                cache_validation_callback=cache_validation_callback
            )
        if self.store_backend is None:
            cls = (AsyncNotMemorizedFunc
                   if asyncio.iscoroutinefunction(func)
                   else NotMemorizedFunc)
            return cls(func)
        if verbose is None:
            verbose = self._verbose
        if mmap_mode is False:
            mmap_mode = self.mmap_mode
        if isinstance(func, MemorizedFunc):
            func = func.func
        cls = (AsyncMemorizedFunc
               if asyncio.iscoroutinefunction(func)
               else MemorizedFunc)
        return cls(
            func, location=self.store_backend, backend=self.backend,
            ignore=ignore, mmap_mode=mmap_mode, compress=self.compress,
            verbose=verbose, timestamp=self.timestamp,
            cache_validation_callback=cache_validation_callback
        )

    def clear(self, warn=True):
        
        if warn:
            self.warn('Flushing completely the cache')
        if self.store_backend is not None:
            self.store_backend.clear()

            
            
            
            
            _FUNCTION_HASHES.clear()

    def reduce_size(self, bytes_limit=None, items_limit=None, age_limit=None):
        
        if bytes_limit is None:
            bytes_limit = self.bytes_limit

        if self.store_backend is None:
            
            return

        if bytes_limit is None and items_limit is None and age_limit is None:
            
            return

        
        self.store_backend.enforce_store_limits(
            bytes_limit, items_limit, age_limit
        )

    def eval(self, func, *args, **kwargs):
        
        if self.store_backend is None:
            return func(*args, **kwargs)
        return self.cache(func)(*args, **kwargs)

    
    
    

    def __repr__(self):
        return '{class_name}(location={location})'.format(
            class_name=self.__class__.__name__,
            location=(None if self.store_backend is None
                      else self.store_backend.location))

    def __getstate__(self):
        
        state = self.__dict__.copy()
        state['timestamp'] = None
        return state






def expires_after(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0,
                  hours=0, weeks=0):
    
    delta = datetime.timedelta(
        days=days, seconds=seconds, microseconds=microseconds,
        milliseconds=milliseconds, minutes=minutes, hours=hours, weeks=weeks
    )

    def cache_validation_callback(metadata):
        computation_age = time.time() - metadata['time']
        return computation_age < delta.total_seconds()

    return cache_validation_callback
