
import os
import sys
import time
import copy
from pathlib import Path


from . import __version__

from .auxfuncs import (
    applyrules, debugcapi, dictappend, errmess, gentitle, getargs2,
    hascallstatement, hasexternals, hasinitvalue, hasnote,
    hasresultnote, isarray, isarrayofstrings, ischaracter,
    ischaracterarray, ischaracter_or_characterarray, iscomplex,
    iscomplexarray, iscomplexfunction, iscomplexfunction_warn,
    isdummyroutine, isexternal, isfunction, isfunction_wrap, isint1,
    isint1array, isintent_aux, isintent_c, isintent_callback,
    isintent_copy, isintent_hide, isintent_inout, isintent_nothide,
    isintent_out, isintent_overwrite, islogical, islong_complex,
    islong_double, islong_doublefunction, islong_long,
    islong_longfunction, ismoduleroutine, isoptional, isrequired,
    isscalar, issigned_long_longarray, isstring, isstringarray,
    isstringfunction, issubroutine, isattr_value,
    issubroutine_wrap, isthreadsafe, isunsigned, isunsigned_char,
    isunsigned_chararray, isunsigned_long_long,
    isunsigned_long_longarray, isunsigned_short, isunsigned_shortarray,
    l_and, l_not, l_or, outmess, replace, stripcomma, requiresf90wrapper
)

from . import capi_maps
from . import cfuncs
from . import common_rules
from . import use_rules
from . import f90mod_rules
from . import func2subr

f2py_version = __version__.version
numpy_version = __version__.version

options = {}
sepdict = {}

for k in ['decl',
          'frompyobj',
          'cleanupfrompyobj',
          'topyarr', 'method',
          'pyobjfrom', 'closepyobjfrom',
          'freemem',
          'userincludes',
          'includes0', 'includes', 'typedefs', 'typedefs_generated',
          'cppmacros', 'cfuncs', 'callbacks',
          'latexdoc',
          'restdoc',
          'routine_defs', 'externroutines',
          'initf2pywraphooks',
          'commonhooks', 'initcommonhooks',
          'f90modhooks', 'initf90modhooks']:
    sepdict[k] = '\n'



generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
module_rules = {
    'modulebody':  + time.asctime(time.gmtime(generationtime)) +  + gentitle("See f2py2e/cfuncs.py: includes") +  + gentitle("See f2py2e/rules.py: mod_rules['modulebody']") +  + gentitle("See f2py2e/cfuncs.py: typedefs") +  + gentitle("See f2py2e/cfuncs.py: typedefs_generated") +  + gentitle("See f2py2e/cfuncs.py: cppmacros") +  + gentitle("See f2py2e/cfuncs.py: cfuncs") +  + gentitle("See f2py2e/cfuncs.py: userincludes") +  + gentitle("See f2py2e/capi_rules.py: usercode") +  + gentitle("See f2py2e/capi_rules.py: usercode1") +  + gentitle("See f2py2e/cb_rules.py: buildcallback") +  + gentitle("See f2py2e/rules.py: buildapi") +  + gentitle("See f2py2e/f90mod_rules.py: buildhooks") +  + gentitle("See f2py2e/rules.py: module_rules['modulebody']") +  + gentitle("See f2py2e/common_rules.py: buildhooks") +  + gentitle("See f2py2e/rules.py") + " + numpy_version + ,
    'separatorsfor': {'latexdoc': '\n\n',
                      'restdoc': '\n\n'},
    'latexdoc': ['\\section{Module \\texttt{
                 '
                 '
    'restdoc': ['Module 
                '\n
}

defmod_rules = [
    {'body': '/*eof body*/',
     'method': '/*eof method*/',
     'externroutines': '/*eof externroutines*/',
     'routine_defs': '/*eof routine_defs*/',
     'initf90modhooks': '/*eof initf90modhooks*/',
     'initf2pywraphooks': '/*eof initf2pywraphooks*/',
     'initcommonhooks': '/*eof initcommonhooks*/',
     'latexdoc': '',
     'restdoc': '',
     'modnote': {hasnote: '
     }
]

routine_rules = {
    'separatorsfor': sepdict,
    'body': ,
    'routine_defs': '
    'initf2pywraphooks': '
    'externroutines': '
    'doc': '
    'docshort': '
    'docs': '"    
    'need': ['arrayobject.h', 'CFUNCSMESS', 'MINMAX'],
    'cppmacros': {debugcapi: '
    'latexdoc': ['\\subsection{Wrapper function \\texttt{
                 ],
    'restdoc': ['Wrapped function ``

                ]
}



rout_rules = [
    {  
        'separatorsfor': {'callfortranroutine': '\n', 'routdebugenter': '\n', 'decl': '\n',
                          'routdebugleave': '\n', 'routdebugfailure': '\n',
                          'setjmpbuf': ' || ',
                          'docstrreq': '\n', 'docstropt': '\n', 'docstrout': '\n',
                          'docstrcbs': '\n', 'docstrsigns': '\\n"\n"',
                          'latexdocstrsigns': '\n',
                          'latexdocstrreq': '\n', 'latexdocstropt': '\n',
                          'latexdocstrout': '\n', 'latexdocstrcbs': '\n',
                          },
        'kwlist': '', 'kwlistopt': '', 'callfortran': '', 'callfortranappend': '',
        'docsign': '', 'docsignopt': '', 'decl': '/*decl*/',
        'freemem': '/*freemem*/',
        'docsignshort': '', 'docsignoptshort': '',
        'docstrsigns': '', 'latexdocstrsigns': '',
        'docstrreq': '\\nParameters\\n----------',
        'docstropt': '\\nOther Parameters\\n----------------',
        'docstrout': '\\nReturns\\n-------',
        'docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n',
        'latexdocstrreq': '\\noindent Required arguments:',
        'latexdocstropt': '\\noindent Optional arguments:',
        'latexdocstrout': '\\noindent Return objects:',
        'latexdocstrcbs': '\\noindent Call-back functions:',
        'args_capi': '', 'keys_capi': '', 'functype': '',
        'frompyobj': '/*frompyobj*/',
        
        'cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'],
        'pyobjfrom': '/*pyobjfrom*/',
        
        'closepyobjfrom': ['/*end of closepyobjfrom*/'],
        'topyarr': '/*topyarr*/', 'routdebugleave': '/*routdebugleave*/',
        'routdebugenter': '/*routdebugenter*/',
        'routdebugfailure': '/*routdebugfailure*/',
        'callfortranroutine': '/*callfortranroutine*/',
        'argformat': '', 'keyformat': '', 'need_cfuncs': '',
        'docreturn': '', 'return': '', 'returnformat': '', 'rformat': '',
        'kwlistxa': '', 'keys_xa': '', 'xaformat': '', 'docsignxa': '', 'docsignxashort': '',
        'initf2pywraphook': '',
        'routnote': {hasnote: '--- 
    }, {
        'apiname': 'f2py_rout_
        'pyname': '
        'decl': '',
        '_check': l_not(ismoduleroutine)
    }, {
        'apiname': 'f2py_rout_
        'pyname': '
        'decl': '',
        '_check': ismoduleroutine
    }, {  
        'functype': 'void',
        'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern void 
                               l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern void 
                               ismoduleroutine: '',
                               isdummyroutine: ''
                               },
        'routine_def': {
            l_not(l_or(ismoduleroutine, isintent_c, isdummyroutine)):
            '    {\"
            '  
            '  (f2py_init_func)
            l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)):
            '    {\"
            '  (f2py_init_func)
            l_and(l_not(ismoduleroutine), isdummyroutine):
            '    {\"
            '  (f2py_init_func)
        },
        'need': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC'},
        'callfortranroutine': [
            {debugcapi: [
                ]},
            {hasexternals: },
            {isthreadsafe: '            Py_BEGIN_ALLOW_THREADS'},
            {hascallstatement: },
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '                (*f2py_func)(
            {isthreadsafe: '            Py_END_ALLOW_THREADS'},
            {hasexternals: }
        ],
        '_check': l_and(issubroutine, l_not(issubroutine_wrap)),
    }, {  
        'functype': 'void',
        'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void 
                               isdummyroutine: '',
                               },

        'routine_def': {
            l_not(l_or(ismoduleroutine, isdummyroutine)):
            '    {\"
            '  
            '  (f2py_init_func)
            isdummyroutine:
            '    {\"
            '  (f2py_init_func)
        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): },
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        'callfortranroutine': [
            {debugcapi: [
                ]},
            {hasexternals: },
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(
            {hascallstatement:
                '    
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            {hasexternals: '    }'}
        ],
        '_check': isfunction_wrap,
    }, {  
        'functype': 'void',
        'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void 
                               isdummyroutine: '',
                               },

        'routine_def': {
            l_not(l_or(ismoduleroutine, isdummyroutine)):
            '    {\"
            '  
            '  (f2py_init_func)
            isdummyroutine:
            '    {\"
            '  (f2py_init_func)
        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): },
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        'callfortranroutine': [
            {debugcapi: [
                ]},
            {hasexternals: },
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    (*f2py_func)(
            {hascallstatement:
                '    
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            {hasexternals: '    }'}
        ],
        '_check': issubroutine_wrap,
    }, {  
        'functype': '
        'docreturn': {l_not(isintent_hide): '
        'docstrout': '
        'latexdocstrout': ['\\item[]{{}\\verb@
                           {hasresultnote: '--- 
        'callfortranroutine': [{l_and(debugcapi, isstringfunction): },
                               {l_and(debugcapi, l_not(isstringfunction)): }
                               ],
        '_check': l_and(isfunction, l_not(isfunction_wrap))
    }, {  
        'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern 
                               l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern 
                               isdummyroutine: ''
                               },
        'routine_def': {
            l_and(l_not(l_or(ismoduleroutine, isintent_c)),
                  l_not(isdummyroutine)):
            ('    {\"
             '  
             '  (f2py_init_func)
            l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)):
            ('    {\"
             '  (f2py_init_func)
            isdummyroutine:
            '    {\"
            '(f2py_init_func)
        },
        'decl': [{iscomplexfunction_warn: '    
                  l_not(iscomplexfunction): '    
                 {iscomplexfunction:
                  '    PyObject *
                 ],
        'callfortranroutine': [
            {hasexternals: },
            {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'},
            {hascallstatement: },
            {l_not(l_or(hascallstatement, isdummyroutine))
                   : '    
            {isthreadsafe: '    Py_END_ALLOW_THREADS'},
            {hasexternals: '    }'},
            {l_and(debugcapi, iscomplexfunction)
                   : '    fprintf(stderr,"
            {l_and(debugcapi, l_not(iscomplexfunction)): '    fprintf(stderr,"
        'pyobjfrom': {iscomplexfunction: '    
        'need': [{l_not(isdummyroutine): 'F_FUNC'},
                 {iscomplexfunction: 'pyobj_from_
                 {islong_longfunction: 'long_long'},
                 {islong_doublefunction: 'long_double'}],
        'returnformat': {l_not(isintent_hide): '
        'return': {iscomplexfunction: ',
                   l_not(l_or(iscomplexfunction, isintent_hide)): ',
        '_check': l_and(isfunction, l_not(isstringfunction), l_not(isfunction_wrap))
    }, {  
        'declfortranroutine': 'extern void 
        'routine_def': {l_not(l_or(ismoduleroutine, isintent_c)):
                        '    {\"
                        l_and(l_not(ismoduleroutine), isintent_c):
                        '    {\"
                        },
        'decl': ['    
                 '    int 
        'callfortran':'
        'callfortranroutine':['    
                              '    if ((
                              + '
                              '        PyErr_SetString(PyExc_MemoryError, \"out of memory\");',
                              '        f2py_success = 0;',
                              '    } else {',
                              "        (
                              '    }',
                              '    if (f2py_success) {',
                              {hasexternals: },
                              {isthreadsafe: '        Py_BEGIN_ALLOW_THREADS'},
                              ,
                              {isthreadsafe: '        Py_END_ALLOW_THREADS'},
                              {hasexternals: '        }'},
                              {debugcapi:
                                  '        fprintf(stderr,"
                              '    } /* if (f2py_success) after (string)malloc */',
                              ],
        'returnformat': '
        'return': ',
        'freemem': '    STRINGFREE(
        'need': ['F_FUNC', '
        '_check':l_and(isstringfunction, l_not(isfunction_wrap))  
    },
    {  
        'routdebugenter': '    fprintf(stderr,"debug-capi:Python C/API function 
        'routdebugleave': '    fprintf(stderr,"debug-capi:Python C/API function 
        'routdebugfailure': '    fprintf(stderr,"debug-capi:Python C/API function 
        '_check': debugcapi
    }
]



typedef_need_dict = {islong_long: 'long_long',
                     islong_double: 'long_double',
                     islong_complex: 'complex_long_double',
                     isunsigned_char: 'unsigned_char',
                     isunsigned_short: 'unsigned_short',
                     isunsigned: 'unsigned',
                     isunsigned_long_long: 'unsigned_long_long',
                     isunsigned_chararray: 'unsigned_char',
                     isunsigned_shortarray: 'unsigned_short',
                     isunsigned_long_longarray: 'unsigned_long_long',
                     issigned_long_longarray: 'long_long',
                     isint1: 'signed_char',
                     ischaracter_or_characterarray: 'character',
                     }

aux_rules = [
    {
        'separatorsfor': sepdict
    },
    {  
        'frompyobj': ['    /* Processing auxiliary variable 
                      {debugcapi: '    fprintf(stderr,"
        'cleanupfrompyobj': '    /* End of cleaning variable 
        'need': typedef_need_dict,
    },
    
    {  
        'decl': '    
        'need': {hasinitvalue: 'math.h'},
        'frompyobj': {hasinitvalue: '    
        '_check': l_and(isscalar, l_not(iscomplex)),
    },
    {
        'return': ',
        'docstrout': '
        'docreturn': '
        'returnformat': '
        '_check': l_and(isscalar, l_not(iscomplex), isintent_out),
    },
    
    {  
        'decl': '    
        'frompyobj': {hasinitvalue: '    
        '_check': iscomplex
    },
    
    {  
        'decl': ['    
                 '    int slen(
                 ],
        'need':['len..'],
        '_check':isstring
    },
    
    {  
        'decl': ['    
                 '    npy_intp 
                 '    const int 
                 ],
        'need':['len..', {hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],
        '_check': isarray
    },
    
    {  
        '_check': l_and(isarray, l_not(iscomplexarray))
    }, {  
        '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)
    },
    
    {'need': '
     '_check': isint1array,
     '_depend': ''
     },
    
    {'need': '
     '_check': l_or(isunsigned_chararray, isunsigned_char),
     '_depend': ''
     },
    
    {'need': '
     '_check': isunsigned_shortarray,
     '_depend': ''
     },
    
    {'need': '
     '_check': isunsigned_long_longarray,
     '_depend': ''
     },
    
    {'need': '
     '_check': iscomplexarray,
     '_depend': ''
     },
    
    {
        'callfortranappend': {isarrayofstrings: 'flen(
        'need': 'string',
        '_check': isstringarray
    }
]

arg_rules = [
    {
        'separatorsfor': sepdict
    },
    {  
        'frompyobj': ['    /* Processing variable 
                      {debugcapi: '    fprintf(stderr,"
        'cleanupfrompyobj': '    /* End of cleaning variable 
        '_depend': '',
        'need': typedef_need_dict,
    },
    
    {
        'docstropt': {l_and(isoptional, isintent_nothide): '
        'docstrreq': {l_and(isrequired, isintent_nothide): '
        'docstrout': {isintent_out: '
        'latexdocstropt': {l_and(isoptional, isintent_nothide): ['\\item[]{{}\\verb@
                                                                 {hasnote: '--- 
        'latexdocstrreq': {l_and(isrequired, isintent_nothide): ['\\item[]{{}\\verb@
                                                                 {hasnote: '--- 
        'latexdocstrout': {isintent_out: ['\\item[]{{}\\verb@
                                          {l_and(hasnote, isintent_hide): '--- 
                                           l_and(hasnote, isintent_nothide): '--- See above.'}]},
        'depend': ''
    },
    
    {
        'kwlist': '"
        'docsign': '
        '_check': l_and(isintent_nothide, l_not(isoptional))
    },
    {
        'kwlistopt': '"
        'docsignopt': '
        'docsignoptshort': '
        '_check': l_and(isintent_nothide, isoptional)
    },
    
    {
        'docreturn': '
        'returnformat': '
        '_check': isintent_out
    },
    
    {  
        'docsignxa': {isintent_nothide: '
        'docsignxashort': {isintent_nothide: '
        'docstropt': {isintent_nothide: '
        'docstrcbs': '
        'latexdocstrcbs': '\\item[] 
        'latexdocstropt': {isintent_nothide: '\\item[]{{}\\verb@
        'decl': ['    
                 '    
                 '    PyTupleObject *
                 {l_not(isintent_callback):
                  '    
                 ],
        'kwlistxa': {isintent_nothide: '"
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'xaformat': {isintent_nothide: 'O!'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'keys_xa': ',&PyTuple_Type,&
        'setjmpbuf': '(setjmp(
        'callfortran': {l_not(isintent_callback): '
        'need': ['
        '_check':isexternal
    },
    {
        'frompyobj': [{l_not(isintent_callback): }, {isintent_callback: },
            ,
            {debugcapi: [,
                         {l_not(isintent_callback): }]},
            ,
        ],
        'cleanupfrompyobj':
        ,
        'need': ['SWAP', 'create_cb_arglist'],
        '_check':isexternal,
        '_depend':''
    },
    
    {  
        'decl': '    
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"
        'callfortran': {l_or(isintent_c, isattr_value): '
        'return': {isintent_out: ',
        '_check': l_and(isscalar, l_not(iscomplex))
    }, {
        'need': {hasinitvalue: 'math.h'},
        '_check': l_and(isscalar, l_not(iscomplex)),
    }, {  
        'decl': '    PyObject *
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'pyobjfrom': {isintent_inout: },
        'closepyobjfrom': {isintent_inout: "    } /*if (f2py_success) of 
        'need': {isintent_inout: 'try_pyarr_from_
        '_check': l_and(isscalar, l_not(iscomplex), l_not(isstring),
                        isintent_nothide)
    }, {
        'frompyobj': [
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            {hasinitvalue: '    if (
             '_depend': ''},
            {l_and(isoptional, l_not(hasinitvalue)): '    if (
             '_depend': ''},
            {l_not(islogical): },
            {islogical: },
        ],
        'cleanupfrompyobj': '    } /*if (f2py_success) of 
        'need': {l_not(islogical): '
        '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide),
        '_depend': ''
    }, {  
        'frompyobj': {hasinitvalue: '    
        'need': typedef_need_dict,
        '_check': l_and(isscalar, l_not(iscomplex), isintent_hide),
        '_depend': ''
    }, {  
        'frompyobj': {debugcapi: '    fprintf(stderr,"
        '_check': l_and(isscalar, l_not(iscomplex)),
        '_depend': ''
    },
    
    {  
        'decl': '    
        'callfortran': {isintent_c: '
        'pyobjfrom': {debugcapi: '    fprintf(stderr,"
        'return': {isintent_out: ',
        '_check': iscomplex
    }, {  
        'decl': '    PyObject *
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'need': {isintent_inout: 'try_pyarr_from_
        'pyobjfrom': {isintent_inout: },
        'closepyobjfrom': {isintent_inout: "        } /*if (f2py_success) of 
        '_check': l_and(iscomplex, isintent_nothide)
    }, {
        'frompyobj': [{hasinitvalue: '    if (
                      {l_and(isoptional, l_not(hasinitvalue))
                             : '    if (
                      '        f2py_success = 
                      '\n    if (f2py_success) {'],
        'cleanupfrompyobj': '    }  /*if (f2py_success) of 
        'need': ['
        '_check': l_and(iscomplex, isintent_nothide),
        '_depend': ''
    }, {  
        'decl': {isintent_out: '    PyObject *
        '_check': l_and(iscomplex, isintent_hide)
    }, {
        'frompyobj': {hasinitvalue: '    
        '_check': l_and(iscomplex, isintent_hide),
        '_depend': ''
    }, {  
        'pyobjfrom': {isintent_out: '    
        'need': ['pyobj_from_
        '_check': iscomplex
    }, {
        'frompyobj': {debugcapi: '    fprintf(stderr,"
        '_check': iscomplex,
        '_depend': ''
    },
    
    {  
        'decl': ['    
                 '    int slen(
                 '    PyObject *
        'callfortran':'
        'callfortranappend':'slen(
        'pyobjfrom':[
            {debugcapi:
             '    fprintf(stderr,'
             '"
            
            {l_and(isintent_out, l_not(isintent_c)):
             "        STRINGPADN(
        ],
        'return': {isintent_out: ',
        'need': ['len..',
                 {l_and(isintent_out, l_not(isintent_c)): 'STRINGPADN'}],
        '_check': isstring
    }, {  
        'frompyobj': [
            

,
            
            {l_not(isintent_c):
             "        STRINGPADN(
        ],
        'cleanupfrompyobj': ,
        'need': ['
                 {l_not(isintent_c): 'STRINGPADN'}],
        '_check':isstring,
        '_depend':''
    }, {  
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        'pyobjfrom': [
            {l_and(isintent_inout, l_not(isintent_c)):
             "        STRINGPADN(
            {isintent_inout: }],
        'closepyobjfrom': {isintent_inout: '    } /*if (f2py_success) of 
        'need': {isintent_inout: 'try_pyarr_from_
                 l_and(isintent_inout, l_not(isintent_c)): 'STRINGPADN'},
        '_check': l_and(isstring, isintent_nothide)
    }, {  
        '_check': l_and(isstring, isintent_hide)
    }, {
        'frompyobj': {debugcapi: '    fprintf(stderr,"
        '_check': isstring,
        '_depend': ''
    },
    
    {  
        'decl': ['    
                 '    npy_intp 
                 '    const int 
                 '    PyArrayObject *capi_
                 '    int capi_
                 {isstringarray: '    int slen(
                 ],
        'callfortran':'
        'callfortranappend': {isstringarray: 'slen(
        'return': {isintent_out: ',capi_
        'need': 'len..',
        '_check': isarray
    }, {  
        'decl': '    int capi_overwrite_
        'kwlistxa': '"overwrite_
        'xaformat': 'i',
        'keys_xa': ',&capi_overwrite_
        'docsignxa': 'overwrite_
        'docsignxashort': 'overwrite_
        'docstropt': 'overwrite_
        '_check': l_and(isarray, isintent_overwrite),
    }, {
        'frompyobj': '    capi_
        '_check': l_and(isarray, isintent_overwrite),
        '_depend': '',
    },
    {  
        'decl': '    int capi_overwrite_
        'kwlistxa': '"overwrite_
        'xaformat': 'i',
        'keys_xa': ',&capi_overwrite_
        'docsignxa': 'overwrite_
        'docsignxashort': 'overwrite_
        'docstropt': 'overwrite_
        '_check': l_and(isarray, isintent_copy),
    }, {
        'frompyobj': '    capi_
        '_check': l_and(isarray, isintent_copy),
        '_depend': '',
    }, {
        'need': [{hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],
        '_check': isarray,
        '_depend': ''
    }, {  
        'decl': '    PyObject *
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'args_capi': {isrequired: ',&
        'keys_capi': {isoptional: ',&
        '_check': l_and(isarray, isintent_nothide)
    }, {
        'frompyobj': [
            '    
            '    capi_
            ('    const char * capi_errmess = "
             ' failed to create array from the 
            {isintent_hide:
             '    capi_
             '  
             '  capi_
            {isintent_nothide:
             '    capi_
             '  
             '  capi_
            ,
            {isstringarray:
             '    slen(
            {hasinitvalue: [
                {isintent_nothide:
                 '    if (
                {isintent_hide: '    {'},
                {iscomplexarray: '        
                ]},
                      ],
        'cleanupfrompyobj': [  
            '    }  '
            '/* if (capi_
            {l_not(l_or(isintent_out, isintent_hide)): },
            {l_and(isintent_hide, l_not(isintent_out))
                   : },
            {hasinitvalue: '    }  /*if (f2py_success) of 
        ],
        '_check': isarray,
        '_depend': ''
    },
    
    {  
        '_check': l_and(isarray, l_not(iscomplexarray))
    }, {  
        '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)
    },
    
    {'need': '
     '_check': isint1array,
     '_depend': ''
     },
    
    {'need': '
     '_check': isunsigned_chararray,
     '_depend': ''
     },
    
    {'need': '
     '_check': isunsigned_shortarray,
     '_depend': ''
     },
    
    {'need': '
     '_check': isunsigned_long_longarray,
     '_depend': ''
     },
    
    {'need': '
     '_check': iscomplexarray,
     '_depend': ''
     },
    
    {
        'need': 'string',
        '_check': ischaracter,
    },
    
    {
        'need': 'string',
        '_check': ischaracterarray,
    },
    
    {
        'callfortranappend': {isarrayofstrings: 'flen(
        'need': 'string',
        '_check': isstringarray
    }
]



check_rules = [
    {
        'frompyobj': {debugcapi: '    fprintf(stderr,\"debug-capi:Checking `
        'need': 'len..'
    }, {
        'frompyobj': '    CHECKSCALAR(
        'cleanupfrompyobj': '    } /*CHECKSCALAR(
        'need': 'CHECKSCALAR',
        '_check': l_and(isscalar, l_not(iscomplex)),
        '_break': ''
    }, {
        'frompyobj': '    CHECKSTRING(
        'cleanupfrompyobj': '    } /*CHECKSTRING(
        'need': 'CHECKSTRING',
        '_check': isstring,
        '_break': ''
    }, {
        'need': 'CHECKARRAY',
        'frompyobj': '    CHECKARRAY(
        'cleanupfrompyobj': '    } /*CHECKARRAY(
        '_check': isarray,
        '_break': ''
    }, {
        'need': 'CHECKGENERIC',
        'frompyobj': '    CHECKGENERIC(
        'cleanupfrompyobj': '    } /*CHECKGENERIC(
    }
]






def buildmodule(m, um):
    
    outmess('    Building module "%s"...\n' % (m['name']))
    ret = {}
    mod_rules = defmod_rules[:]
    vrd = capi_maps.modsign2map(m)
    rd = dictappend({'f2py_version': f2py_version}, vrd)
    funcwrappers = []
    funcwrappers2 = []  
    for n in m['interfaced']:
        nb = None
        for bi in m['body']:
            if bi['block'] not in ['interface', 'abstract interface']:
                errmess('buildmodule: Expected interface block. Skipping.\n')
                continue
            for b in bi['body']:
                if b['name'] == n:
                    nb = b
                    break

        if not nb:
            print(
                'buildmodule: Could not find the body of interfaced routine "%s". Skipping.\n' % (n), file=sys.stderr)
            continue
        nb_list = [nb]
        if 'entry' in nb:
            for k, a in nb['entry'].items():
                nb1 = copy.deepcopy(nb)
                del nb1['entry']
                nb1['name'] = k
                nb1['args'] = a
                nb_list.append(nb1)
        for nb in nb_list:
            
            
            isf90 = requiresf90wrapper(nb)
            
            if options['emptygen']:
                b_path = options['buildpath']
                m_name = vrd['modulename']
                outmess('    Generating possibly empty wrappers"\n')
                Path(f"{b_path}/{vrd['coutput']}").touch()
                if isf90:
                    
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers2.f90"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers2.f90').touch()
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()
                else:
                    
                    outmess(f'    Maybe empty "{m_name}-f2pywrappers.f"\n')
                    Path(f'{b_path}/{m_name}-f2pywrappers.f').touch()
            api, wrap = buildapi(nb)
            if wrap:
                if isf90:
                    funcwrappers2.append(wrap)
                else:
                    funcwrappers.append(wrap)
            ar = applyrules(api, vrd)
            rd = dictappend(rd, ar)

    
    cr, wrap = common_rules.buildhooks(m)
    if wrap:
        funcwrappers.append(wrap)
    ar = applyrules(cr, vrd)
    rd = dictappend(rd, ar)

    
    mr, wrap = f90mod_rules.buildhooks(m)
    if wrap:
        funcwrappers2.append(wrap)
    ar = applyrules(mr, vrd)
    rd = dictappend(rd, ar)

    for u in um:
        ar = use_rules.buildusevars(u, m['use'][u['name']])
        rd = dictappend(rd, ar)

    needs = cfuncs.get_needs()
    
    needs['typedefs'] += [cvar for cvar in capi_maps.f2cmap_mapped 
                          if cvar in typedef_need_dict.values()]
    code = {}
    for n in needs.keys():
        code[n] = []
        for k in needs[n]:
            c = ''
            if k in cfuncs.includes0:
                c = cfuncs.includes0[k]
            elif k in cfuncs.includes:
                c = cfuncs.includes[k]
            elif k in cfuncs.userincludes:
                c = cfuncs.userincludes[k]
            elif k in cfuncs.typedefs:
                c = cfuncs.typedefs[k]
            elif k in cfuncs.typedefs_generated:
                c = cfuncs.typedefs_generated[k]
            elif k in cfuncs.cppmacros:
                c = cfuncs.cppmacros[k]
            elif k in cfuncs.cfuncs:
                c = cfuncs.cfuncs[k]
            elif k in cfuncs.callbacks:
                c = cfuncs.callbacks[k]
            elif k in cfuncs.f90modhooks:
                c = cfuncs.f90modhooks[k]
            elif k in cfuncs.commonhooks:
                c = cfuncs.commonhooks[k]
            else:
                errmess('buildmodule: unknown need %s.\n' % (repr(k)))
                continue
            code[n].append(c)
    mod_rules.append(code)
    for r in mod_rules:
        if ('_check' in r and r['_check'](m)) or ('_check' not in r):
            ar = applyrules(r, vrd, m)
            rd = dictappend(rd, ar)
    ar = applyrules(module_rules, rd)

    fn = os.path.join(options['buildpath'], vrd['coutput'])
    ret['csrc'] = fn
    with open(fn, 'w') as f:
        f.write(ar['modulebody'].replace('\t', 2 * ' '))
    outmess('    Wrote C/API module "%s" to file "%s"\n' % (m['name'], fn))

    if options['dorestdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.rest')
        with open(fn, 'w') as f:
            f.write('.. -*- rest -*-\n')
            f.write('\n'.join(ar['restdoc']))
        outmess('    ReST Documentation is saved to file "%s/%smodule.rest"\n' %
                (options['buildpath'], vrd['modulename']))
    if options['dolatexdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.tex')
        ret['ltx'] = fn
        with open(fn, 'w') as f:
            f.write(
                '%% This file is auto-generated with f2py (version:%s)\n' % (f2py_version))
            if 'shortlatex' not in options:
                f.write(
                    '\\documentclass{article}\n\\usepackage{a4wide}\n\\begin{document}\n\\tableofcontents\n\n')
                f.write('\n'.join(ar['latexdoc']))
            if 'shortlatex' not in options:
                f.write('\\end{document}')
        outmess('    Documentation is saved to file "%s/%smodule.tex"\n' %
                (options['buildpath'], vrd['modulename']))
    if funcwrappers:
        wn = os.path.join(options['buildpath'], vrd['f2py_wrapper_output'])
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('C     -*- fortran -*-\n')
            f.write(
                'C     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                'C     It contains Fortran 77 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers) + '\n').split('\n'):
                if 0 <= l.find('!') < 66:
                    
                    lines.append(l + '\n')
                elif l and l[0] == ' ':
                    while len(l) >= 66:
                        lines.append(l[:66] + '\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess('    Fortran 77 wrappers are saved to "%s"\n' % (wn))
    if funcwrappers2:
        wn = os.path.join(
            options['buildpath'], '%s-f2pywrappers2.f90' % (vrd['modulename']))
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('!     -*- f90 -*-\n')
            f.write(
                '!     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                '!     It contains Fortran 90 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers2) + '\n').split('\n'):
                if 0 <= l.find('!') < 72:
                    
                    lines.append(l + '\n')
                elif len(l) > 72 and l[0] == ' ':
                    lines.append(l[:72] + '&\n     &')
                    l = l[72:]
                    while len(l) > 66:
                        lines.append(l[:66] + '&\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess('    Fortran 90 wrappers are saved to "%s"\n' % (wn))
    return ret



stnd = {1: 'st', 2: 'nd', 3: 'rd', 4: 'th', 5: 'th',
        6: 'th', 7: 'th', 8: 'th', 9: 'th', 0: 'th'}


def buildapi(rout):
    rout, wrap = func2subr.assubr(rout)
    args, depargs = getargs2(rout)
    capi_maps.depargs = depargs
    var = rout['vars']

    if ismoduleroutine(rout):
        outmess('            Constructing wrapper function "%s.%s"...\n' %
                (rout['modulename'], rout['name']))
    else:
        outmess('        Constructing wrapper function "%s"...\n' % (rout['name']))
    
    vrd = capi_maps.routsign2map(rout)
    rd = dictappend({}, vrd)
    for r in rout_rules:
        if ('_check' in r and r['_check'](rout)) or ('_check' not in r):
            ar = applyrules(r, vrd, rout)
            rd = dictappend(rd, ar)

    
    nth, nthk = 0, 0
    savevrd = {}
    for a in args:
        vrd = capi_maps.sign2map(a, var[a])
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
            if not isintent_hide(var[a]):
                if not isoptional(var[a]):
                    nth = nth + 1
                    vrd['nth'] = repr(nth) + stnd[nth % 10] + ' argument'
                else:
                    nthk = nthk + 1
                    vrd['nth'] = repr(nthk) + stnd[nthk % 10] + ' keyword'
            else:
                vrd['nth'] = 'hidden'
        savevrd[a] = vrd
        for r in _rules:
            if '_depend' in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    for a in depargs:
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
        vrd = savevrd[a]
        for r in _rules:
            if '_depend' not in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
        if 'check' in var[a]:
            for c in var[a]['check']:
                vrd['check'] = c
                ar = applyrules(check_rules, vrd, var[a])
                rd = dictappend(rd, ar)
    if isinstance(rd['cleanupfrompyobj'], list):
        rd['cleanupfrompyobj'].reverse()
    if isinstance(rd['closepyobjfrom'], list):
        rd['closepyobjfrom'].reverse()
    rd['docsignature'] = stripcomma(replace('
                                            {'docsign': rd['docsign'],
                                             'docsignopt': rd['docsignopt'],
                                             'docsignxa': rd['docsignxa']}))
    optargs = stripcomma(replace('
                                 {'docsignxa': rd['docsignxashort'],
                                  'docsignopt': rd['docsignoptshort']}
                                 ))
    if optargs == '':
        rd['docsignatureshort'] = stripcomma(
            replace('
    else:
        rd['docsignatureshort'] = replace('
                                          {'docsign': rd['docsign'],
                                           'docsignopt': optargs,
                                           })
    rd['latexdocsignatureshort'] = rd['docsignatureshort'].replace('_', '\\_')
    rd['latexdocsignatureshort'] = rd[
        'latexdocsignatureshort'].replace(',', ', ')
    cfs = stripcomma(replace('
                     'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    if len(rd['callfortranappend']) > 1:
        rd['callcompaqfortran'] = stripcomma(replace('
                                             'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    else:
        rd['callcompaqfortran'] = cfs
    rd['callfortran'] = cfs
    if isinstance(rd['docreturn'], list):
        rd['docreturn'] = stripcomma(
            replace('
    rd['docstrsigns'] = []
    rd['latexdocstrsigns'] = []
    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:
        if k in rd and isinstance(rd[k], list):
            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]
        k = 'latex' + k
        if k in rd and isinstance(rd[k], list):
            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] +\
                ['\\begin{description}'] + rd[k][1:] +\
                ['\\end{description}']

    ar = applyrules(routine_rules, rd)
    if ismoduleroutine(rout):
        outmess('              %s\n' % (ar['docshort']))
    else:
        outmess('          %s\n' % (ar['docshort']))
    return ar, wrap



