




import itertools

from ..base import ClassNamePrefixFeaturesOutMixin, TransformerMixin, _fit_context
from ..utils._param_validation import (
    Integral,
    Interval,
    Real,
    StrOptions,
    validate_params,
)
from ..utils.validation import check_is_fitted
from ._base import VALID_METRICS, KNeighborsMixin, NeighborsBase, RadiusNeighborsMixin
from ._unsupervised import NearestNeighbors


def _check_params(X, metric, p, metric_params):
    
    params = zip(["metric", "p", "metric_params"], [metric, p, metric_params])
    est_params = X.get_params()
    for param_name, func_param in params:
        if func_param != est_params[param_name]:
            raise ValueError(
                "Got %s for %s, while the estimator has %s for the same parameter."
                % (func_param, param_name, est_params[param_name])
            )


def _query_include_self(X, include_self, mode):
    
    if include_self == "auto":
        include_self = mode == "connectivity"

    
    if not include_self:
        X = None

    return X


@validate_params(
    {
        "X": ["array-like", "sparse matrix", KNeighborsMixin],
        "n_neighbors": [Interval(Integral, 1, None, closed="left")],
        "mode": [StrOptions({"connectivity", "distance"})],
        "metric": [StrOptions(set(itertools.chain(*VALID_METRICS.values()))), callable],
        "p": [Interval(Real, 0, None, closed="right"), None],
        "metric_params": [dict, None],
        "include_self": ["boolean", StrOptions({"auto"})],
        "n_jobs": [Integral, None],
    },
    prefer_skip_nested_validation=False,  
)
def kneighbors_graph(
    X,
    n_neighbors,
    *,
    mode="connectivity",
    metric="minkowski",
    p=2,
    metric_params=None,
    include_self=False,
    n_jobs=None,
):
    
    if not isinstance(X, KNeighborsMixin):
        X = NearestNeighbors(
            n_neighbors=n_neighbors,
            metric=metric,
            p=p,
            metric_params=metric_params,
            n_jobs=n_jobs,
        ).fit(X)
    else:
        _check_params(X, metric, p, metric_params)

    query = _query_include_self(X._fit_X, include_self, mode)
    return X.kneighbors_graph(X=query, n_neighbors=n_neighbors, mode=mode)


@validate_params(
    {
        "X": ["array-like", "sparse matrix", RadiusNeighborsMixin],
        "radius": [Interval(Real, 0, None, closed="both")],
        "mode": [StrOptions({"connectivity", "distance"})],
        "metric": [StrOptions(set(itertools.chain(*VALID_METRICS.values()))), callable],
        "p": [Interval(Real, 0, None, closed="right"), None],
        "metric_params": [dict, None],
        "include_self": ["boolean", StrOptions({"auto"})],
        "n_jobs": [Integral, None],
    },
    prefer_skip_nested_validation=False,  
)
def radius_neighbors_graph(
    X,
    radius,
    *,
    mode="connectivity",
    metric="minkowski",
    p=2,
    metric_params=None,
    include_self=False,
    n_jobs=None,
):
    
    if not isinstance(X, RadiusNeighborsMixin):
        X = NearestNeighbors(
            radius=radius,
            metric=metric,
            p=p,
            metric_params=metric_params,
            n_jobs=n_jobs,
        ).fit(X)
    else:
        _check_params(X, metric, p, metric_params)

    query = _query_include_self(X._fit_X, include_self, mode)
    return X.radius_neighbors_graph(query, radius, mode)


class KNeighborsTransformer(
    ClassNamePrefixFeaturesOutMixin, KNeighborsMixin, TransformerMixin, NeighborsBase
):
    

    _parameter_constraints: dict = {
        **NeighborsBase._parameter_constraints,
        "mode": [StrOptions({"distance", "connectivity"})],
    }
    _parameter_constraints.pop("radius")

    def __init__(
        self,
        *,
        mode="distance",
        n_neighbors=5,
        algorithm="auto",
        leaf_size=30,
        metric="minkowski",
        p=2,
        metric_params=None,
        n_jobs=None,
    ):
        super(KNeighborsTransformer, self).__init__(
            n_neighbors=n_neighbors,
            radius=None,
            algorithm=algorithm,
            leaf_size=leaf_size,
            metric=metric,
            p=p,
            metric_params=metric_params,
            n_jobs=n_jobs,
        )
        self.mode = mode

    @_fit_context(
        
        prefer_skip_nested_validation=False
    )
    def fit(self, X, y=None):
        
        self._fit(X)
        self._n_features_out = self.n_samples_fit_
        return self

    def transform(self, X):
        
        check_is_fitted(self)
        add_one = self.mode == "distance"
        return self.kneighbors_graph(
            X, mode=self.mode, n_neighbors=self.n_neighbors + add_one
        )

    def fit_transform(self, X, y=None):
        
        return self.fit(X).transform(X)


class RadiusNeighborsTransformer(
    ClassNamePrefixFeaturesOutMixin,
    RadiusNeighborsMixin,
    TransformerMixin,
    NeighborsBase,
):
    

    _parameter_constraints: dict = {
        **NeighborsBase._parameter_constraints,
        "mode": [StrOptions({"distance", "connectivity"})],
    }
    _parameter_constraints.pop("n_neighbors")

    def __init__(
        self,
        *,
        mode="distance",
        radius=1.0,
        algorithm="auto",
        leaf_size=30,
        metric="minkowski",
        p=2,
        metric_params=None,
        n_jobs=None,
    ):
        super(RadiusNeighborsTransformer, self).__init__(
            n_neighbors=None,
            radius=radius,
            algorithm=algorithm,
            leaf_size=leaf_size,
            metric=metric,
            p=p,
            metric_params=metric_params,
            n_jobs=n_jobs,
        )
        self.mode = mode

    @_fit_context(
        
        prefer_skip_nested_validation=False
    )
    def fit(self, X, y=None):
        
        self._fit(X)
        self._n_features_out = self.n_samples_fit_
        return self

    def transform(self, X):
        
        check_is_fitted(self)
        return self.radius_neighbors_graph(X, mode=self.mode, sort_results=True)

    def fit_transform(self, X, y=None):
        
        return self.fit(X).transform(X)
