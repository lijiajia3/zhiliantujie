from __future__ import annotations

import warnings
from collections import OrderedDict
from dataclasses import dataclass, field
from itertools import chain

from .fixes import _dataclass_args





@dataclass(**_dataclass_args())
class InputTags:
    

    one_d_array: bool = False
    two_d_array: bool = True
    three_d_array: bool = False
    sparse: bool = False
    categorical: bool = False
    string: bool = False
    dict: bool = False
    positive_only: bool = False
    allow_nan: bool = False
    pairwise: bool = False


@dataclass(**_dataclass_args())
class TargetTags:
    

    required: bool
    one_d_labels: bool = False
    two_d_labels: bool = False
    positive_only: bool = False
    multi_output: bool = False
    single_output: bool = True


@dataclass(**_dataclass_args())
class TransformerTags:
    

    preserves_dtype: list[str] = field(default_factory=lambda: ["float64"])


@dataclass(**_dataclass_args())
class ClassifierTags:
    

    poor_score: bool = False
    multi_class: bool = True
    multi_label: bool = False


@dataclass(**_dataclass_args())
class RegressorTags:
    

    poor_score: bool = False


@dataclass(**_dataclass_args())
class Tags:
    

    estimator_type: str | None
    target_tags: TargetTags
    transformer_tags: TransformerTags | None = None
    classifier_tags: ClassifierTags | None = None
    regressor_tags: RegressorTags | None = None
    array_api_support: bool = False
    no_validation: bool = False
    non_deterministic: bool = False
    requires_fit: bool = True
    _skip_test: bool = False
    input_tags: InputTags = field(default_factory=InputTags)



def default_tags(estimator) -> Tags:
    
    est_is_classifier = getattr(estimator, "_estimator_type", None) == "classifier"
    est_is_regressor = getattr(estimator, "_estimator_type", None) == "regressor"
    target_required = est_is_classifier or est_is_regressor

    return Tags(
        estimator_type=getattr(estimator, "_estimator_type", None),
        target_tags=TargetTags(required=target_required),
        transformer_tags=(
            TransformerTags()
            if hasattr(estimator, "transform") or hasattr(estimator, "fit_transform")
            else None
        ),
        classifier_tags=ClassifierTags() if est_is_classifier else None,
        regressor_tags=RegressorTags() if est_is_regressor else None,
    )



def _find_tags_provider(estimator, warn=True):
    
    mro_model = type(estimator).mro()
    tags_mro = OrderedDict()
    for klass in mro_model:
        tags_provider = []
        if "_more_tags" in vars(klass):
            tags_provider.append("_more_tags")
        if "_get_tags" in vars(klass):
            tags_provider.append("_get_tags")
        if "__sklearn_tags__" in vars(klass):
            tags_provider.append("__sklearn_tags__")
        tags_mro[klass.__name__] = tags_provider

    all_providers = set(chain.from_iterable(tags_mro.values()))
    if "__sklearn_tags__" not in all_providers:
        
        return "_get_tags"

    tag_provider = "__sklearn_tags__"
    for klass in tags_mro:
        has_get_or_more_tags = any(
            provider in tags_mro[klass] for provider in ("_get_tags", "_more_tags")
        )
        has_sklearn_tags = "__sklearn_tags__" in tags_mro[klass]

        if tags_mro[klass] and tag_provider == "__sklearn_tags__":  
            if has_get_or_more_tags and not has_sklearn_tags:
                
                
                
                tag_provider = "_get_tags"
                break

    if warn and tag_provider == "_get_tags":
        warnings.warn(
            f"The {estimator.__class__.__name__} or classes from which it inherits "
            "use `_get_tags` and `_more_tags`. Please define the "
            "`__sklearn_tags__` method, or inherit from `sklearn.base.BaseEstimator` "
            "and/or other appropriate mixins such as `sklearn.base.TransformerMixin`, "
            "`sklearn.base.ClassifierMixin`, `sklearn.base.RegressorMixin`, and "
            "`sklearn.base.OutlierMixin`. From scikit-learn 1.7, not defining "
            "`__sklearn_tags__` will raise an error.",
            category=DeprecationWarning,
        )
    return tag_provider


def get_tags(estimator) -> Tags:
    

    tag_provider = _find_tags_provider(estimator)

    if tag_provider == "__sklearn_tags__":
        
        try:
            tags = estimator.__sklearn_tags__()
        except AttributeError as exc:
            if str(exc) == "'super' object has no attribute '__sklearn_tags__'":
                
                
                
                
                
                warnings.warn(
                    f"The following error was raised: {str(exc)}. It seems that "
                    "there are no classes that implement `__sklearn_tags__` "
                    "in the MRO and/or all classes in the MRO call "
                    "`super().__sklearn_tags__()`. Make sure to inherit from "
                    "`BaseEstimator` which implements `__sklearn_tags__` (or "
                    "alternatively define `__sklearn_tags__` but we don't recommend "
                    "this approach). Note that `BaseEstimator` needs to be on the "
                    "right side of other Mixins in the inheritance order. The "
                    "default are now used instead since retrieving tags failed. "
                    "This warning will be replaced by an error in 1.7.",
                    category=DeprecationWarning,
                )
                tags = default_tags(estimator)
            else:
                raise
    else:
        
        
        sklearn_tags_provider = {}
        more_tags_provider = {}
        class_order = []
        for klass in reversed(type(estimator).mro()):
            if "__sklearn_tags__" in vars(klass):
                sklearn_tags_provider[klass] = klass.__sklearn_tags__(estimator)  
                class_order.append(klass)
            elif "_more_tags" in vars(klass):
                more_tags_provider[klass] = klass._more_tags(estimator)  
                class_order.append(klass)

        
        
        sklearn_tags_diff = {}
        items = list(sklearn_tags_provider.items())
        for current_item, next_item in zip(items[:-1], items[1:]):
            current_name, current_tags = current_item
            next_name, next_tags = next_item
            current_tags = _to_old_tags(current_tags)
            next_tags = _to_old_tags(next_tags)

            
            diff = {}
            for key in current_tags:
                if current_tags[key] != next_tags[key]:
                    diff[key] = next_tags[key]

            sklearn_tags_diff[next_name] = diff

        tags = {}
        for klass in class_order:
            if klass in sklearn_tags_diff:
                tags.update(sklearn_tags_diff[klass])
            elif klass in more_tags_provider:
                tags.update(more_tags_provider[klass])

        tags = _to_new_tags(
            {**_to_old_tags(default_tags(estimator)), **tags}, estimator
        )

    return tags



def _safe_tags(estimator, key=None):
    warnings.warn(
        "The `_safe_tags` function is deprecated in 1.6 and will be removed in "
        "1.7. Use the public `get_tags` function instead and make sure to implement "
        "the `__sklearn_tags__` method.",
        category=DeprecationWarning,
    )
    tags = _to_old_tags(get_tags(estimator))

    if key is not None:
        if key not in tags:
            raise ValueError(
                f"The key {key} is not defined for the class "
                f"{estimator.__class__.__name__}."
            )
        return tags[key]
    return tags



def _to_new_tags(old_tags, estimator=None):
    
    input_tags = InputTags(
        one_d_array="1darray" in old_tags["X_types"],
        two_d_array="2darray" in old_tags["X_types"],
        three_d_array="3darray" in old_tags["X_types"],
        sparse="sparse" in old_tags["X_types"],
        categorical="categorical" in old_tags["X_types"],
        string="string" in old_tags["X_types"],
        dict="dict" in old_tags["X_types"],
        positive_only=old_tags["requires_positive_X"],
        allow_nan=old_tags["allow_nan"],
        pairwise=old_tags["pairwise"],
    )
    target_tags = TargetTags(
        required=old_tags["requires_y"],
        one_d_labels="1dlabels" in old_tags["X_types"],
        two_d_labels="2dlabels" in old_tags["X_types"],
        positive_only=old_tags["requires_positive_y"],
        multi_output=old_tags["multioutput"] or old_tags["multioutput_only"],
        single_output=not old_tags["multioutput_only"],
    )
    if estimator is not None and (
        hasattr(estimator, "transform") or hasattr(estimator, "fit_transform")
    ):
        transformer_tags = TransformerTags(
            preserves_dtype=old_tags["preserves_dtype"],
        )
    else:
        transformer_tags = None
    estimator_type = getattr(estimator, "_estimator_type", None)
    if estimator_type == "classifier":
        classifier_tags = ClassifierTags(
            poor_score=old_tags["poor_score"],
            multi_class=not old_tags["binary_only"],
            multi_label=old_tags["multilabel"],
        )
    else:
        classifier_tags = None
    if estimator_type == "regressor":
        regressor_tags = RegressorTags(
            poor_score=old_tags["poor_score"],
        )
    else:
        regressor_tags = None
    return Tags(
        estimator_type=estimator_type,
        target_tags=target_tags,
        transformer_tags=transformer_tags,
        classifier_tags=classifier_tags,
        regressor_tags=regressor_tags,
        input_tags=input_tags,
        array_api_support=old_tags["array_api_support"],
        no_validation=old_tags["no_validation"],
        non_deterministic=old_tags["non_deterministic"],
        requires_fit=old_tags["requires_fit"],
        _skip_test=old_tags["_skip_test"],
    )



def _to_old_tags(new_tags):
    
    if new_tags.classifier_tags:
        binary_only = not new_tags.classifier_tags.multi_class
        multilabel = new_tags.classifier_tags.multi_label
        poor_score_clf = new_tags.classifier_tags.poor_score
    else:
        binary_only = False
        multilabel = False
        poor_score_clf = False

    if new_tags.regressor_tags:
        poor_score_reg = new_tags.regressor_tags.poor_score
    else:
        poor_score_reg = False

    if new_tags.transformer_tags:
        preserves_dtype = new_tags.transformer_tags.preserves_dtype
    else:
        preserves_dtype = ["float64"]

    tags = {
        "allow_nan": new_tags.input_tags.allow_nan,
        "array_api_support": new_tags.array_api_support,
        "binary_only": binary_only,
        "multilabel": multilabel,
        "multioutput": new_tags.target_tags.multi_output,
        "multioutput_only": (
            not new_tags.target_tags.single_output and new_tags.target_tags.multi_output
        ),
        "no_validation": new_tags.no_validation,
        "non_deterministic": new_tags.non_deterministic,
        "pairwise": new_tags.input_tags.pairwise,
        "preserves_dtype": preserves_dtype,
        "poor_score": poor_score_clf or poor_score_reg,
        "requires_fit": new_tags.requires_fit,
        "requires_positive_X": new_tags.input_tags.positive_only,
        "requires_y": new_tags.target_tags.required,
        "requires_positive_y": new_tags.target_tags.positive_only,
        "_skip_test": new_tags._skip_test,
        "stateless": new_tags.requires_fit,
    }
    X_types = []
    if new_tags.input_tags.one_d_array:
        X_types.append("1darray")
    if new_tags.input_tags.two_d_array:
        X_types.append("2darray")
    if new_tags.input_tags.three_d_array:
        X_types.append("3darray")
    if new_tags.input_tags.sparse:
        X_types.append("sparse")
    if new_tags.input_tags.categorical:
        X_types.append("categorical")
    if new_tags.input_tags.string:
        X_types.append("string")
    if new_tags.input_tags.dict:
        X_types.append("dict")
    if new_tags.target_tags.one_d_labels:
        X_types.append("1dlabels")
    if new_tags.target_tags.two_d_labels:
        X_types.append("2dlabels")
    tags["X_types"] = X_types
    return tags
